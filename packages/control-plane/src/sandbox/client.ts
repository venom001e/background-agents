/**
 * Modal sandbox API client.
 *
 * Provides methods to interact with Modal sandboxes from the control plane.
 * All requests are authenticated using HMAC-signed tokens.
 */

import { generateInternalToken } from "@CodInspect/shared";

// Modal app name
const MODAL_APP_NAME = "CodInspect";

/**
 * Construct the Modal base URL from workspace name.
 * Modal endpoint URLs follow the pattern: https://{workspace}--{app-name}
 */
function getModalBaseUrl(workspace: string): string {
  return `https://${workspace}--${MODAL_APP_NAME}`;
}

export interface CreateSandboxRequest {
  sessionId: string;
  sandboxId?: string; // Expected sandbox ID (generated by control plane)
  repoOwner: string;
  repoName: string;
  controlPlaneUrl: string;
  sandboxAuthToken: string;
  snapshotId?: string;
  opencodeSessionId?: string;
  gitUserName?: string;
  gitUserEmail?: string;
  provider?: string;
  model?: string;
}

export interface CreateSandboxResponse {
  sandboxId: string;
  modalObjectId?: string; // Modal's internal object ID for snapshot API
  status: string;
  createdAt: number;
}

export interface WarmSandboxRequest {
  repoOwner: string;
  repoName: string;
  controlPlaneUrl?: string;
}

export interface WarmSandboxResponse {
  sandboxId: string;
  status: string;
}

export interface SnapshotInfo {
  id: string;
  repoOwner: string;
  repoName: string;
  baseSha: string;
  status: string;
  createdAt: string;
  expiresAt?: string;
}

interface ModalApiResponse<T> {
  success: boolean;
  data?: T;
  error?: string;
}

/**
 * Modal sandbox API client.
 *
 * Requires MODAL_API_SECRET for authentication and MODAL_WORKSPACE for URL construction.
 */
export class ModalClient {
  private createSandboxUrl: string;
  private warmSandboxUrl: string;
  private healthUrl: string;
  private snapshotUrl: string;
  private snapshotSandboxUrl: string;
  private restoreSandboxUrl: string;
  private secret: string;

  constructor(secret: string, workspace: string) {
    if (!secret) {
      throw new Error("ModalClient requires MODAL_API_SECRET for authentication");
    }
    if (!workspace) {
      throw new Error("ModalClient requires MODAL_WORKSPACE for URL construction");
    }
    this.secret = secret;
    const baseUrl = getModalBaseUrl(workspace);
    this.createSandboxUrl = `${baseUrl}-api-create-sandbox.modal.run`;
    this.warmSandboxUrl = `${baseUrl}-api-warm-sandbox.modal.run`;
    this.healthUrl = `${baseUrl}-api-health.modal.run`;
    this.snapshotUrl = `${baseUrl}-api-snapshot.modal.run`;
    this.snapshotSandboxUrl = `${baseUrl}-api-snapshot-sandbox.modal.run`;
    this.restoreSandboxUrl = `${baseUrl}-api-restore-sandbox.modal.run`;
  }

  /**
   * Get the URL for the snapshot sandbox endpoint.
   */
  getSnapshotSandboxUrl(): string {
    return this.snapshotSandboxUrl;
  }

  /**
   * Get the URL for the restore sandbox endpoint.
   */
  getRestoreSandboxUrl(): string {
    return this.restoreSandboxUrl;
  }

  /**
   * Generate authentication headers for POST/PUT requests (includes Content-Type).
   */
  private async getPostHeaders(): Promise<Record<string, string>> {
    const token = await generateInternalToken(this.secret);
    return {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    };
  }

  /**
   * Generate authentication headers for GET requests (no Content-Type).
   */
  private async getGetHeaders(): Promise<Record<string, string>> {
    const token = await generateInternalToken(this.secret);
    return {
      Authorization: `Bearer ${token}`,
    };
  }

  /**
   * Create a new sandbox for a session.
   */
  async createSandbox(request: CreateSandboxRequest): Promise<CreateSandboxResponse> {
    console.log("Creating sandbox via Modal API:", request.sessionId);

    const headers = await this.getPostHeaders();
    const response = await fetch(this.createSandboxUrl, {
      method: "POST",
      headers,
      body: JSON.stringify({
        session_id: request.sessionId,
        sandbox_id: request.sandboxId || null, // Use control-plane-generated ID
        repo_owner: request.repoOwner,
        repo_name: request.repoName,
        control_plane_url: request.controlPlaneUrl,
        sandbox_auth_token: request.sandboxAuthToken,
        snapshot_id: request.snapshotId || null,
        opencode_session_id: request.opencodeSessionId || null,
        git_user_name: request.gitUserName || null,
        git_user_email: request.gitUserEmail || null,
        provider: request.provider || "anthropic",
        model: request.model || "claude-sonnet-4-5",
      }),
    });

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Modal API error: ${response.status} ${text}`);
    }

    const result = (await response.json()) as ModalApiResponse<{
      sandbox_id: string;
      modal_object_id?: string;
      status: string;
      created_at: number;
    }>;

    if (!result.success || !result.data) {
      throw new Error(`Modal API error: ${result.error || "Unknown error"}`);
    }

    return {
      sandboxId: result.data.sandbox_id,
      modalObjectId: result.data.modal_object_id,
      status: result.data.status,
      createdAt: result.data.created_at,
    };
  }

  /**
   * Pre-warm a sandbox for faster startup.
   */
  async warmSandbox(request: WarmSandboxRequest): Promise<WarmSandboxResponse> {
    console.log("Warming sandbox via Modal API:", request.repoOwner, request.repoName);

    const headers = await this.getPostHeaders();
    const response = await fetch(this.warmSandboxUrl, {
      method: "POST",
      headers,
      body: JSON.stringify({
        repo_owner: request.repoOwner,
        repo_name: request.repoName,
        control_plane_url: request.controlPlaneUrl || "",
      }),
    });

    if (!response.ok) {
      const text = await response.text();
      throw new Error(`Modal API error: ${response.status} ${text}`);
    }

    const result = (await response.json()) as ModalApiResponse<{
      sandbox_id: string;
      status: string;
    }>;

    if (!result.success || !result.data) {
      throw new Error(`Modal API error: ${result.error || "Unknown error"}`);
    }

    return {
      sandboxId: result.data.sandbox_id,
      status: result.data.status,
    };
  }

  /**
   * Check Modal API health.
   * Note: Health endpoint does not require authentication.
   */
  async health(): Promise<{ status: string; service: string }> {
    const response = await fetch(this.healthUrl);

    if (!response.ok) {
      throw new Error(`Modal API error: ${response.status}`);
    }

    const result = (await response.json()) as ModalApiResponse<{
      status: string;
      service: string;
    }>;

    if (!result.success || !result.data) {
      throw new Error(`Modal API error: ${result.error || "Unknown error"}`);
    }

    return result.data;
  }

  /**
   * Get the latest snapshot for a repository.
   */
  async getLatestSnapshot(repoOwner: string, repoName: string): Promise<SnapshotInfo | null> {
    const url = `${this.snapshotUrl}?repo_owner=${encodeURIComponent(repoOwner)}&repo_name=${encodeURIComponent(repoName)}`;

    const headers = await this.getGetHeaders();
    const response = await fetch(url, { headers });

    if (!response.ok) {
      return null;
    }

    const result = (await response.json()) as ModalApiResponse<SnapshotInfo>;

    if (!result.success) {
      return null;
    }

    return result.data || null;
  }
}

/**
 * Create a new Modal client instance.
 *
 * This is a simple factory function that creates a new client each time.
 * The caller is responsible for managing the client lifecycle.
 *
 * @param secret - The MODAL_API_SECRET for authentication
 * @param workspace - The Modal workspace name (used in endpoint URLs)
 * @returns A new ModalClient instance
 * @throws Error if secret or workspace is not provided
 */
export function createModalClient(secret: string, workspace: string): ModalClient {
  if (!secret) {
    throw new Error("MODAL_API_SECRET is required to create ModalClient");
  }
  if (!workspace) {
    throw new Error("MODAL_WORKSPACE is required to create ModalClient");
  }
  return new ModalClient(secret, workspace);
}
