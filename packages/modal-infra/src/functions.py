"""
Modal function definitions for CodInspect API.

These functions expose the sandbox management operations as
Modal functions that can be called from the control plane.

Note: Uses lazy imports to avoid pydantic dependency at module load time.
"""

import os

from .app import app, function_image, github_app_secrets, inspect_volume

# Global sandbox manager (lazy loaded)
_manager = None


def get_manager():
    """Get or create the sandbox manager instance."""
    global _manager
    if _manager is None:
        from .sandbox.manager import SandboxManager

        _manager = SandboxManager()
    return _manager


@app.function(image=function_image, volumes={"/data": inspect_volume}, secrets=[github_app_secrets])
async def create_sandbox(
    session_id: str,
    repo_owner: str,
    repo_name: str,
    control_plane_url: str,
    sandbox_auth_token: str,
    sandbox_id: str | None = None,
    snapshot_id: str | None = None,
    opencode_session_id: str | None = None,
    git_user_name: str | None = None,
    git_user_email: str | None = None,
    provider: str = "anthropic",
    model: str = "claude-sonnet-4-20250514",
) -> dict:
    """
    Create a new sandbox for a session.

    Args:
        session_id: Unique session identifier
        repo_owner: GitHub repository owner
        repo_name: GitHub repository name
        control_plane_url: URL for control plane WebSocket
        sandbox_auth_token: Authentication token for sandbox
        sandbox_id: Expected sandbox ID (generated by control plane for auth)
        snapshot_id: Optional snapshot to restore from
        opencode_session_id: Optional existing OpenCode session ID
        git_user_name: Git user name for commits
        git_user_email: Git user email for commits
        provider: LLM provider (anthropic, openai)
        model: Model identifier

    Returns:
        dict with sandbox_id and status
    """
    # Lazy imports to avoid pydantic at module load time
    from .auth.github_app import generate_installation_token
    from .sandbox.manager import SandboxConfig
    from .sandbox.types import GitUser, SessionConfig

    manager = get_manager()

    # Generate GitHub App token for git operations (sync, push)
    github_app_token = None
    try:
        app_id = os.environ.get("GITHUB_APP_ID")
        private_key = os.environ.get("GITHUB_APP_PRIVATE_KEY")
        installation_id = os.environ.get("GITHUB_APP_INSTALLATION_ID")

        if app_id and private_key and installation_id:
            github_app_token = generate_installation_token(
                app_id=app_id,
                private_key=private_key,
                installation_id=installation_id,
            )
    except Exception as e:
        # Log but don't fail - public repos can work without token
        print(f"Warning: Failed to generate GitHub App token: {e}")

    # Build session config
    git_user = None
    if git_user_name and git_user_email:
        git_user = GitUser(name=git_user_name, email=git_user_email)

    session_config = SessionConfig(
        session_id=session_id,
        repo_owner=repo_owner,
        repo_name=repo_name,
        opencode_session_id=opencode_session_id,
        provider=provider,
        model=model,
        git_user=git_user,
    )

    config = SandboxConfig(
        repo_owner=repo_owner,
        repo_name=repo_name,
        sandbox_id=sandbox_id,  # Use control-plane-provided ID for auth validation
        snapshot_id=snapshot_id,
        session_config=session_config,
        control_plane_url=control_plane_url,
        sandbox_auth_token=sandbox_auth_token,
        github_app_token=github_app_token,
    )

    handle = await manager.create_sandbox(config)

    return {
        "sandbox_id": handle.sandbox_id,
        "status": handle.status.value,
        "created_at": handle.created_at,
    }


@app.function(image=function_image, volumes={"/data": inspect_volume})
async def warm_sandbox(
    repo_owner: str,
    repo_name: str,
    control_plane_url: str = "",
) -> dict:
    """
    Pre-warm a sandbox for faster startup.

    Called when user starts typing to reduce latency.

    Args:
        repo_owner: GitHub repository owner
        repo_name: GitHub repository name
        control_plane_url: Optional control plane URL

    Returns:
        dict with sandbox_id
    """
    manager = get_manager()
    handle = await manager.warm_sandbox(
        repo_owner=repo_owner,
        repo_name=repo_name,
        control_plane_url=control_plane_url,
    )

    return {
        "sandbox_id": handle.sandbox_id,
        "status": handle.status.value,
    }


@app.function(image=function_image, volumes={"/data": inspect_volume})
def get_latest_snapshot(repo_owner: str, repo_name: str) -> dict | None:
    """
    Get the latest snapshot for a repository.

    Args:
        repo_owner: GitHub repository owner
        repo_name: GitHub repository name

    Returns:
        Snapshot info or None if no snapshot exists
    """
    # Lazy import to avoid pydantic at module load time
    from .registry.store import SnapshotStore

    store = SnapshotStore()
    snapshot = store.get_latest_snapshot(repo_owner, repo_name)

    if snapshot:
        return snapshot.model_dump()
    return None


@app.function(image=function_image, volumes={"/data": inspect_volume})
def list_snapshots(repo_owner: str, repo_name: str, limit: int = 10) -> list[dict]:
    """
    List recent snapshots for a repository.

    Args:
        repo_owner: GitHub repository owner
        repo_name: GitHub repository name
        limit: Maximum number of snapshots to return

    Returns:
        List of snapshot info dicts
    """
    # Lazy import to avoid pydantic at module load time
    from .registry.store import SnapshotStore

    store = SnapshotStore()
    snapshots = store.list_snapshots(repo_owner, repo_name, limit=limit)
    return [s.model_dump() for s in snapshots]


@app.function(image=function_image, volumes={"/data": inspect_volume})
def register_repository(
    repo_owner: str,
    repo_name: str,
    default_branch: str = "main",
    setup_commands: list[str] | None = None,
    build_commands: list[str] | None = None,
) -> dict:
    """
    Register a repository for scheduled image builds.

    Args:
        repo_owner: GitHub repository owner
        repo_name: GitHub repository name
        default_branch: Default branch to build from
        setup_commands: Custom setup commands
        build_commands: Custom build commands

    Returns:
        Repository configuration
    """
    # Lazy imports to avoid pydantic at module load time
    from .registry.models import Repository
    from .registry.store import SnapshotStore

    store = SnapshotStore()

    repo = Repository(
        owner=repo_owner,
        name=repo_name,
        default_branch=default_branch,
        setup_commands=setup_commands or [],
        build_commands=build_commands or [],
    )

    store.save_repository(repo)

    return repo.model_dump()


@app.function(image=function_image, volumes={"/data": inspect_volume})
def list_repositories() -> list[dict]:
    """
    List all registered repositories.

    Returns:
        List of repository configurations
    """
    # Lazy import to avoid pydantic at module load time
    from .registry.store import SnapshotStore

    store = SnapshotStore()
    repos = store.list_repositories()
    return [r.model_dump() for r in repos]


@app.function(image=function_image, volumes={"/data": inspect_volume})
def delete_repository(repo_owner: str, repo_name: str) -> dict:
    """
    Delete a repository from the registry.

    Args:
        repo_owner: GitHub repository owner
        repo_name: GitHub repository name

    Returns:
        dict with success status
    """
    # Lazy import to avoid pydantic at module load time
    from .registry.store import SnapshotStore

    store = SnapshotStore()
    deleted = store.delete_repository(repo_owner, repo_name)

    return {
        "deleted": deleted,
        "repo_owner": repo_owner,
        "repo_name": repo_name,
    }


# Health check endpoint
@app.function(image=function_image)
def health_check() -> dict:
    """Health check endpoint."""
    return {
        "status": "healthy",
        "service": "CodInspect-modal",
    }
